/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CCAL.jj */
/*@egen*/options{
	JAVA_UNICODE_ESCAPE = true;
	IGNORE_CASE = true;
               
                 
                           
}

PARSER_BEGIN(CCAL)

import java.io.*;
import java.util.*;

  public class CCAL/*@bgen(jjtree)*/implements CCALTreeConstants/*@egen*/
  {/*@bgen(jjtree)*/
  protected static JJTCCALState jjtree = new JJTCCALState();

/*@egen*/
    public static Hashtable SymbolTable = new Hashtable();
    public static void main(String args[]) throws ParseException, FileNotFoundException
    {
      CCAL parser;

   		if (args.length == 0)
      {
         System.out.println("Please pass in the filename");
         System.exit(1);
      }
      else
      {
   		 parser = new CCAL(new FileInputStream(args[0]));

       SimpleNode root = parser.Program();

       System.out.println("Abstract Syntax Tree:");
       root.dump(" ");

       System.out.println("\n\n********Semantic Analysis********\n");
       SemanticCheckVisitor check = new SemanticCheckVisitor();
       root.jjtAccept(check, null);
       }
    }
   }
PARSER_END(CCAL)


TOKEN_MGR_DECLS :
{
   static int commentNesting = 0;
}

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SKIP : /* COMMENTS */
{
	< "//" (~["\n"])* "\n" >
  | "//" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
  "/*" { commentNesting++; }
| "*/" { commentNesting--; if (commentNesting == 0) SwitchTo(DEFAULT); }
| <~[]>
}

TOKEN :
{
  < COMMA : "," >
| < SEMI_COLON : ";" >
| < COLON : ":" >
| < EQUALS : "=" >
| < LBR : "(" >
| < RBR : ")" >
| < PLUS_SIGN : "+" >
| < MINUS_SIGN : "-" >
| < TILDA : "~" >
| < OR_SIGN : "||" >
| < AND_SIGN : "&&" >
| < EQUAL_TO : "==" >
| < NOT_EQUAL_TO : "!=" >
| < LESS_THAN : "<" >
| < LESS_OR_EQUAL : "<=" >
| < GREATER_THAN : ">" >
| < GREATER_OR_EQUAL : ">=" >
}

TOKEN :
{
    < VAR : "var" >
  | < CONST : "const" >
  | < RETURN : "return" >
  | < INTEGER : "integer" >
  | < BOOLEAN : "boolean" >
  | < VOID : "void" >
  | < MAIN : "main" >
  | < IF : "if" >
  | < ELSE : "else" >
  | < TRUE : "true" >
  | < FALSE : "false" >
  | < WHILE : "while" >
	| < BEGIN : "begin" >
	| < END : "end" >
	| < IS : "is" >
	| < SKIP_IT : "skip" >
}

TOKEN :
{
 		< NUMBER: ( "-" ["1"-"9"] (<DIGIT>)* ) |
			( ["1"-"9"] (<DIGIT>)* ) | "0" >
	| < #DIGIT : ["0" - "9"] >
	| < ID : <LETTER> (<LETTER> | <DIGIT> | "_")* >
	| < #LETTER : ["a" - "z", "A" - "Z"] >
}

SimpleNode Program ()          :{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  decl_list() function_list() main()/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl_list () :{}{
  decl()<SEMI_COLON>decl_list() | {}
}

void decl () :{}{
  var_decl() | const_decl()
}

void var_decl ()       :{/*@bgen(jjtree) Decl */
  ASTDecl jjtn000 = new ASTDecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Decl */
  try {
/*@egen*/
  <VAR> identifier()<COLON>type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void const_decl ()        :{/*@bgen(jjtree) Const */
  ASTConst jjtn000 = new ASTConst(JJTCONST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Const */
  try {
/*@egen*/
  <CONST> identifier()<COLON>type() <EQUALS> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_list ()           :{/*@bgen(jjtree) FuncList */
  ASTFuncList jjtn000 = new ASTFuncList(JJTFUNCLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FuncList */
  try {
/*@egen*/
  function() function_list() |/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function ()       :{/*@bgen(jjtree) Func */
  ASTFunc jjtn000 = new ASTFunc(JJTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Func */
  try {
/*@egen*/
  type()identifier()<LBR>parameter_list()<RBR> <IS>
  decl_list()
	<BEGIN>
  statement_block()
  <RETURN><LBR>[expression()]<RBR><SEMI_COLON>
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void parameter_list ()         :{/*@bgen(jjtree) Params */
  ASTParams jjtn000 = new ASTParams(JJTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Params */
  try {
/*@egen*/
  nemp_parameter_list() |/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_parameter_list () :{}{
	LOOKAHEAD(2)
  identifier() <COLON> type() | identifier() <COLON> type() [<COMMA> nemp_parameter_list()]
}

void main ()       :{/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Main */
  try {
/*@egen*/
  <MAIN> <BEGIN>
  decl_list()
  statement_block()
  <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type()       : {/*@bgen(jjtree) Type */
                      ASTType jjtn000 = new ASTType(JJTTYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Type */
      try {
/*@egen*/
      t = <INTEGER>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ { jjtn000.value = token;}
    | t = <BOOLEAN>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ { jjtn000.value = token;}
    | t = <VOID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}

void statement_block () :{}{
  statement() statement_block() | {}
}

void statement ()             :{/*@bgen(jjtree) StateBlock */
  ASTStateBlock jjtn000 = new ASTStateBlock(JJTSTATEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) StateBlock */
        try {
/*@egen*/
	LOOKAHEAD(2)
  identifier() <EQUALS> expression() <SEMI_COLON>
	| identifier() <LBR> arg_list() <RBR> <SEMI_COLON>
  | <BEGIN> statement_block() <END>
  | <IF> condition() <BEGIN> statement_block() <END> <ELSE> <BEGIN> statement_block() <END>
	| <WHILE> condition() <BEGIN> statement_block() <END>
  | <SKIP_IT> <SEMI_COLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void expression(): {}
{
    fragment() bin_expr()
|   <LBR> expression() <RBR> bin_expr()
}

void bin_expr() : {}
{
    binary_op() expression()
|   {}
}

void binary_op ()        : {/*@bgen(jjtree) BinOp */
  ASTBinOp jjtn000 = new ASTBinOp(JJTBINOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) BinOp */
  try {
/*@egen*//*@bgen(jjtree) Add */
  {
    ASTAdd jjtn001 = new ASTAdd(JJTADD);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  <PLUS_SIGN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/     
|/*@bgen(jjtree) Sub */
  {
    ASTSub jjtn002 = new ASTSub(JJTSUB);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ <MINUS_SIGN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/     /*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void fragment () :{}{
  identifier() [<LBR> arg_list() <RBR>] | <MINUS_SIGN> identifier() | number() | boolValue()
}

void condition () :{}{
	<TILDA> condition()
	| LOOKAHEAD(2) <LBR> condition() <RBR>
	| expression() comp_op() expression()
	| cond_sign()
}

void cond_sign() : {}
{
    <OR_SIGN>/*@bgen(jjtree) OR */
              {
                ASTOR jjtn001 = new ASTOR(JJTOR);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ condition()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001, true);
                }
              }
/*@egen*/    
  | <AND_SIGN>/*@bgen(jjtree) AND */
               {
                 ASTAND jjtn002 = new ASTAND(JJTAND);
                 boolean jjtc002 = true;
                 jjtree.openNodeScope(jjtn002);
               }
               try {
/*@egen*/ condition()/*@bgen(jjtree)*/
               } catch (Throwable jjte002) {
                 if (jjtc002) {
                   jjtree.clearNodeScope(jjtn002);
                   jjtc002 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte002 instanceof RuntimeException) {
                   throw (RuntimeException)jjte002;
                 }
                 if (jjte002 instanceof ParseException) {
                   throw (ParseException)jjte002;
                 }
                 throw (Error)jjte002;
               } finally {
                 if (jjtc002) {
                   jjtree.closeNodeScope(jjtn002, true);
                 }
               }
/*@egen*/     
  | {}
}

void comp_op ()         :{/*@bgen(jjtree) CompOp */
  ASTCompOp jjtn000 = new ASTCompOp(JJTCOMPOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) CompOp */
    try {
/*@egen*//*@bgen(jjtree) Equal */
    {
      ASTEqual jjtn001 = new ASTEqual(JJTEQUAL);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <EQUAL_TO>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/       
  |/*@bgen(jjtree) NotEqual */
    {
      ASTNotEqual jjtn002 = new ASTNotEqual(JJTNOTEQUAL);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ <NOT_EQUAL_TO>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/          
  |/*@bgen(jjtree) LessThan */
    {
      ASTLessThan jjtn003 = new ASTLessThan(JJTLESSTHAN);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/ <LESS_THAN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003, true);
      }
    }
/*@egen*/          
  |/*@bgen(jjtree) LessOrEqual */
    {
      ASTLessOrEqual jjtn004 = new ASTLessOrEqual(JJTLESSOREQUAL);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/ <LESS_OR_EQUAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
      }
    }
/*@egen*/             
  |/*@bgen(jjtree) GreaterThan */
    {
      ASTGreaterThan jjtn005 = new ASTGreaterThan(JJTGREATERTHAN);
      boolean jjtc005 = true;
      jjtree.openNodeScope(jjtn005);
    }
    try {
/*@egen*/ <GREATER_THAN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc005) {
        jjtree.closeNodeScope(jjtn005, true);
      }
    }
/*@egen*/             
  |/*@bgen(jjtree) GreaterOrEqual */
    {
      ASTGreaterOrEqual jjtn006 = new ASTGreaterOrEqual(JJTGREATEROREQUAL);
      boolean jjtc006 = true;
      jjtree.openNodeScope(jjtn006);
    }
    try {
/*@egen*/ <GREATER_OR_EQUAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc006) {
        jjtree.closeNodeScope(jjtn006, true);
      }
    }
/*@egen*/                /*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list ()          :{/*@bgen(jjtree) ArgList */
  ASTArgList jjtn000 = new ASTArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ArgList */
  try {
/*@egen*/
  (nemp_arg_list() |/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {})/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_arg_list () :{}{
	identifier() [<COMMA> nemp_arg_list()]
}

void identifier()     : {/*@bgen(jjtree) Id */
                          ASTId jjtn000 = new ASTId(JJTID);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Id */
        try {
/*@egen*/
	t = <ID>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void number()      : {/*@bgen(jjtree) Num */
                       ASTNum jjtn000 = new ASTNum(JJTNUM);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Num */
        try {
/*@egen*/
	t = <NUMBER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void boolValue()       : {/*@bgen(jjtree) Bool */
                           ASTBool jjtn000 = new ASTBool(JJTBOOL);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Bool */
        try {
/*@egen*/
	t = <TRUE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.value = token;} | t = <FALSE>/*@bgen(jjtree)*/
                                                           {
                                                             jjtree.closeNodeScope(jjtn000, true);
                                                             jjtc000 = false;
                                                           }
/*@egen*/ { jjtn000.value = token;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
